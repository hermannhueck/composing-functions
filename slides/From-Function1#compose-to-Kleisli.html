<!DOCTYPE html>
<html>
  <head>
    <title>From Function1#compose to Kleisli</title>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <meta name="keywords" content="Scala,Cats,Function,Composition,Functor,Monad,Monoid,Kleisli,Reader">
    <meta name="description" content="A talk on the merits of Applicative.">

    <style type="text/css">
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body {
        font-family: 'Droid Serif';
      }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: 400;
        margin-bottom: 0;
      }
      .remark-slide-content h1 { font-size: 4em; }
      .remark-slide-content h2 { font-size: 2.5em; }
      .remark-slide-content h3 { font-size: 1.6em; }
      .footnote {
        position: absolute;
        bottom: 3em;
      }
      li p { line-height: 1.25em; }
      .red { color: #fa0000; }
      .large { font-size: 2em; }
      a, a > code {
        color: rgb(249, 38, 114);
        text-decoration: none;
      }
      code {
        background: #e7e8e2;
        border-radius: 5px;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
      .remark-code-line-highlighted     { background-color: #373832; }
      .pull-left {
        float: left;
        width: 47%;
      }
      .pull-right {
        float: right;
        width: 47%;
      }
      .pull-right ~ p {
        clear: both;
      }
      #slideshow .slide .content code {
        font-size: 0.8em;
      }
      #slideshow .slide .content pre code {
        font-size: 0.9em;
        padding: 15px;
      }
      .inverse {
        background: #014908e1;
        color: #f3f3f3;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

      /* Slide-specific styling */
      #slide-inverse .footnote {
        bottom: 12px;
        left: 20px;
      }
      #slide-how .slides {
        font-size: 0.9em;
        position: absolute;
        top:  151px;
        right: 140px;
      }
      #slide-how .slides h3 {
        margin-top: 0.2em;
      }
      #slide-how .slides .first, #slide-how .slides .second {
        padding: 1px 20px;
        height: 90px;
        width: 120px;
        -moz-box-shadow: 0 0 10px #777;
        -webkit-box-shadow: 0 0 10px #777;
        box-shadow: 0 0 10px #777;
      }
      #slide-how .slides .first {
        background: #fff;
        position: absolute;
        top: 20%;
        left: 20%;
        z-index: 1;
      }
      #slide-how .slides .second {
        position: relative;
        background: #fff;
        z-index: 0;
      }

      /* Two-column layout */
      .left-column {
        color: #777;
        width: 20%;
        height: 92%;
        float: left;
      }
      .left-column h2:last-of-type, .left-column h3:last-child {
        color: #000;
      }
      .right-column {
        width: 75%;
        float: right;
        padding-top: 1em;
      }

      /* Two-column layout 50/50 */
      .left-column-50 {
        width: 49%;
        float: left;
      }
      .right-column-50 {
        width: 49%;
        float: right;
      }

      .tiny-font {
        font-size: 1em
      }
    </style>
  </head>
  <body>

<textarea id="source">

name: main-template
layout: true
class: left, top
<!---
class: left, top, inverse
-->

---

class: center

<br/>
# From Function1#compose to Kleisli

## Different Ways of Function Composition

<br/>
<br/>
## &copy; 2018 Hermann Hueck
<br/>
https://github.com/hermannhueck/composing-functions

---

# Abstract (1/2)

Fine-grained composability of functions is one of the core advantages of FP.

Treating "Functions as Data" means that we can ...
- store a function in a val
- pass it as args to other (higher order) functions (HOFs)
- return a function from other functions
- process/manipulate a function like data
- organize functions in data structures like List, Option etc.
- wrap a function in a case class

In this talk I demonstrate different ways of function composition
(and manipulation - what is often the same).

I only deal with *scala.Function1*, because due to currying we can regard
any function (except *Function0*) as a *Function1*. Curried functions are easier to compose.

---

# Abstract (2/2)

I start with the methods on Function1: *compose* and *andThen*.
Then I show how to fold a List of functions.

Then I turn to function composition with Monoids.

Functions are Functors (if *Functor* for *Function1* is defined), i.e they can be mapped over.

Functions are Monads (if *Monad* for *Function1* is defined), i.e they can be flatMapped over.

With *map* and *flatMap* we can write for-comprehensions over functions.
As Monads, we can use them in any monadic context.

Next I implement my own *mycats.Kleisli* similar to *cats.data.Kleisli*
and show its usage with *flatMap*, *flatMapF*, *andThen* and *compose*.

Finally I show the *Reader* Monad, a *Kleisli* simplified with *Id*.

---

# Agenda
<br/>

1. Preliminaries
  - Kind Projector
  - Partial Unification
1. Functions as Data
1. Curried Functions
1. *Function1#compose* and *Function1#andThen*
1. Monoidal Function Composition
1. *Function1* as Functor
1. *Function1* as Monad
1. Kleisli Composition done manually
1. *case class Kleisli*
1. Reader Monad
1. Resources

---

class: middle, center

# 1. Preliminaries
<br/>
<br/>
<br/>
<br/>
<br/>

.left[
### 1.1 Kind Projector
### 1.2 Partial Unification
]

---

## 1.1 Kind Projector - Compiler Plugin
<br/>
<br/>
<br/>

Enable *kind-projector* in *build.sbt*:

```scala
addCompilerPlugin("org.spire-math" %% "kind-projector" % "0.9.7")
```

<br/>
<br/>
<br/>
Kind projector on Github:<br/>
https://github.com/non/kind-projector


.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo01aKindProjector*
]

---

## The Problem:

### How to define a Functor or a Monad for an ADT with two type parameters?

--

A Functor is defined like this:
<br/>

```scala
trait Functor[F[_]] {
  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

It is parameterized with a generic type constructor F[\_] which "has one hole",
i.e. F[\_] needs another type parameter when reified.

--

Hence it is easy to define a Functor instance for *List*, *Option* or *Future*, ADTs which
expect <u>exactly one type parameter</u> that "fills that hole".

--

```scala
implicit val listFunctor: Functor[List] = new Functor[List] {
  override def map[A, B](fa: List[A])(f: A => B): List[B] = fa map f
}

implicit val optionFunctor: Functor[Option] = new Functor[Option] {
  override def map[A, B](fa: Option[A])(f: A => B): Option[B] = fa map f
}
```

--

*List*, *Option* and *Future* have kind: _\* --> \*_

---

### What if we want to define a Functor for *Either*?

--

*Either* has kind: _\* --> \* --> \*_. It has two holes
and hence cannot be used easily to define a Functor or a Monad instance.

--

But we can fix one of the type parameters and leave the other one open.

```scala
// Code compiles without kind-projector.
// It uses a type alias within a structural type.
implicit def eitherFunctor[L]: Functor[({type f[x] = Either[L, x]})#f] =
  new Functor[({type f[x] = Either[L, x]})#f] {
    override def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] = fa map f
  }
```

--

This is a type lambda (analogous to a partially applied function on the value level).

The type alias must be defined inside *def eitherFunctor[L]*
because the type parameter *L* is used in the type alias. This is done
inside a structural type where *f* is returned through a type projection.

```scala
Functor[({type f[x] = Either[L, x]})#f]
```

This code is ugly but can be improved if *kind-projector* is enabled.

---

### Without *kind-projector*:

```scala
implicit def eitherFunctor[L]: Functor[({type f[x] = Either[L, x]})#f] =
  new Functor[({type f[x] = Either[L, x]})#f] {
    override def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] = fa map f
  }
```

--

### With *kind-projector*:

```scala
implicit def eitherFunctor[L]: Functor[Lambda[x => Either[L, x]]] =
  new Functor[Lambda[x => Either[L, x]]] {
    override def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] = fa map f
  }
```

--

```scala
implicit def eitherFunctor[L]: Functor[λ[x => Either[L, x]]] =
  new Functor[λ[x => Either[L, x]]] {
    override def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] = fa map f
  }
```

--

```scala
implicit def eitherFunctor[L]: Functor[Either[L, ?]] =
  new Functor[Either[L, ?]] {
    override def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] = fa map f
  }
```

---

## 1.2 Compiler Flag *-Ypartial-unification*
<br/>
<br/>
<br/>

Enable partial unification in *build.sbt*:

```scala
scalacOptions += "-Ypartial-unification"
```

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo01bPartialUnification*
]

---

## The Problem:

```scala
def foo[F[_], A](fa: F[A]): String = fa.toString

foo { x: Int => x * 2 }


-------
[error] no type parameters for method foo: (fa: F[A])String exist
        so that it can be applied to arguments (Int => Int)
[error]  --- because ---
[error] argument expression's type is not compatible with formal parameter type;
[error]  found   : Int => Int
[error]  required: ?F[?A]
[error]   foo { x: Int => x * 2 }
[error]   ^
[error] type mismatch;
[error]  found   : Int => Int
[error]  required: F[A]
[error]   foo((x: Int) => x * 2)

```

--

This code doesn't compile without *-Ypartial-unification*. &nbsp; &nbsp; &nbsp; **Why?**

--

*def foo* requires a type constructor F[\_] with "one hole". It's kind is: _\* --> \*_.

*foo* is invoked with a function *Int => Int*.
*Int => Int* is syntactic sugar for *Function1[Int, Int]*.
*Function1* like *Either* has two holes. It's kind is: _\* --> \* --> \*_.

---

## The Solution:

*-Ypartial-unification* solves the problem by partially fixing (unifying) the type parameters
<u>from left to right</u> until it fits to the number of holes required by the definition of *foo*.

--

Imagine this flag turns *Function1[A, B]* into *Function1Int[B]*.
With this fix on the fly *Function1Int* has kind _\* --> \*_ which is the kind required by F[\_].
What the compiler transforms the invocation to would look something like this:

```scala
def foo[F[_], A](fa: F[A]): String = fa.toString

foo[Function1Int, Int] { x: Int => x * 2 }
```

--

Note that the partial unification fixes the types always in a <u>left-to-right order</u>
which is a good fit for most cases where we have <u>right-biased types</u> like
*Either*, *Tuple2* or *Function1*. (It is not a good fit for the very rare cases
when you use a left-biased type like Scalactic's *Or* data type (a left-biased *Either*).)

---

## When to use *kind-projector* and *-Ypartial-unification* ?
<br/>

--

Enable plugin and the flag when using a Functor, Applicative or a Monad instance
for higher-kinded types which take more than one type parameter. *Either*, *Tuple2*
and *Function1* are the best known representatives of this kind of types.

When programming on the type level regard both as your friends and keep them enabled.

<br/>

--

Very good explanations of partial unification by Miles Sabin and Daniel Spiewak
can be found at these links:

https://github.com/scala/scala/pull/5102
https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2

---

class: middle, center

# 2. Functions as Data
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Treating Functions as Data (1/2)

allows us to ...

--

- store a function in a val

```scala
val str2Int: String => Int = str => str.toInt
```

--

- pass it as arg to other (higher order) functions (HOFs)

```scala
val mapped = List("1", "2", "3").map(str2Int)
```

--

- return a function from other functions

```scala
val plus100: Int => Int = { i =>
  val j = manipulate(i)
  j + 100
}
```

--

- process/manipulate a function like data

```scala
str2Int map plus100     // Functor instance for Function1 must be defined
```

---

## Treating Functions as Data (2/2)

allows us to ...

--

- organize functions (like data) in data structures like List, Option etc.

```scala
val functions: List[Int => Int] = List(_ + 1, _ + 2, _ + 3)
val f[Int => Int] = functions.foldRight(...)(...)
```

--

- wrap a function in a case class *MyWrapper*

We can define methods on *MyWrapper* which manipulate the wrapped function
and return the manipulation result again wrapped in a new instance of *case class MyWrapper*.


```scala
case class MyWrapper[A, B](run: A => B) {

  def map[C](f: B => C): MyWrapper[A, C] = ???

  def flatMap[C](f: B => MyWrapper[A, C]): MyWrapper[A, C] = ???

  // other methods ...
}
```

---

class: middle, center

# 3. Curried functions
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo03CurriedFunctions*
]

---

## Every function is a *Function1* ...

--

```scala
val sum3Ints : (Int, Int, Int) => Int        = _ + _ + _
val sum3Ints2: Function3[Int, Int, Int, Int] = _ + _ + _
```

--

... if you curry it.

--

```scala
val sumCurried: Int => Int => Int => Int = sum3Ints.curried
// sumCurried: Int => (Int => (Int => Int)) = scala.Function3$$Lambda$4346/99143056@43357c0e
```

--

The type arrow ( => ) is right associative.
Hence we can omit the parentheses.

--

The type arrow ( => ) is syntactic sugar for *Function1*.<br/>
*A => B* is equivalent to *Function1[A, B]*.

--

```scala
val sumCurried2: Function1[Int, Function1[Int, Function1[Int, Int]]] = sumCurried
// sumCurried2: Int => (Int => (Int => Int)) = scala.Function3$$Lambda$4346/99143056@7567ab8
```

--

If uncurried again, we get the original function back.

```scala
val sumUncurried: (Int, Int, Int) => Int = Function.uncurried(sumCurried)
// sumUncurried: (Int, Int, Int) => Int = scala.Function$$$Lambda$6605/301079867@1589d895
```

---

## Partial application of curried functions
<br/>

--

```scala
val sum3Ints: (Int, Int, Int) => Int = _ + _ + _
val sumCurried: Int => Int => Int => Int = sum3Ints.curried
```

--

```scala
val applied1st: Int => Int => Int = sumCurried(1)
// applied1st: Int => (Int => Int) = scala.Function3$$Lambda$4348/1531035406@5a231dc1
```

--

```scala
val applied2nd: Int => Int = applied1st(2)
// applied2nd: Int => Int = scala.Function3$$Lambda$4349/402963549@117e96fb
```

--

```scala
val applied3rd: Int = applied2nd(3)
// applied3rd: Int = 6
```

--

```scala
val appliedAllAtOnce: Int = sumCurried(1)(2)(3)
// appliedAllAtOnce: Int = 6
```

---

## Advantages of curried functions
<br/>

--

1. Curried functions can be partially applied.<br/>
They are better <u>composable</u> than their uncurried counterparts.

--

2. Curried functions (and methods) help the compiler with type inference. The compiler infers types
by argument lists from left to right.

--

```scala
def filter1[A](la: List[A], p: A => Boolean) = ??? // uncurried

scala> filter1(List(0,1,2), _ < 2)
<console>:50: error: missing parameter type for expanded function ((x$1: <error>) => x$1.$less(2))
       filter1(List(0,1,2), _ < 2)
                            ^
```

--

```scala
def filter2[A](la: List[A])(p: A => Boolean) = ??? // curried

scala> filter2(List(0,1,2))(_ < 2)
res5: List[Int] = List(0,1)
```

---

class: middle, center

# 4. *Function1#compose* and Function1#apply
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo04ComposingFunctions*
]

---

## Trait *Function1*
<br/>

```scala
trait Function1[-T1, +R] {

  def apply(a: T1): R
  def compose[A](g: A => T1): A => R = { x => apply(g(x)) }
  def andThen[A](g: R => A): T1 => A = { x => g(apply(x)) }
  override def toString = "<function1>"
}
```
<br/>

--

```scala
scala> val f: Int => Int = _ + 10
f: Int => Int = $$Lambda$4204/320646851@733dc5b7

scala> val g: Int => Int = _ * 2
g: Int => Int = $$Lambda$4205/1093482910@3a179009

scala> (f compose g apply 1) == f(g(1))
res6: Boolean = true

scala> (f andThen g apply 1) == g(f(1))
res7: Boolean = true
```

---

## A pipeline of functions
<br/>
--

```scala
val s2i: String => Int = _.toInt
val plus2: Int => Int = _ + 2
val div10By: Int => Double = 10.0 / _
val d2s: Double => String = _.toString
```
<br/>

--

```scala
// Function1#compose
val fComposed1: String => String = d2s compose div10By compose plus2 compose s2i
val res1 = fComposed1("3") // 2.0 !!!
```

--

```scala
// Function1#andThen
val fComposed2: String => String = s2i andThen plus2 andThen div10By andThen d2s
val res2 = fComposed2("3") // 2.0 !!!
```

---

## Folding a List of Functions
<br/>

--

```scala
val lf: List[Int => Int] = List(_*2, _+10, _+100)
```
<br/>

--

```scala
val lfFoldedRight = lf.foldRight(identity[Int] _) {(f, acc) => acc andThen f}
val resLfFoldedRight = lfFoldedRight(1)
// 222
```

--

```scala
val lfFoldedLeft = lf.foldLeft(identity[Int] _) {(acc, f) => acc andThen f}
val resLfFoldedLeft = lfFoldedLeft(1)
// 112
```

--

<br/>
The *identity* function is the no-op of function composition.

--

Folding functions is not a commutative operation!<br/>
Hence *foldRight* and *foldLeft* return different results.

---

class: middle, center

# 5. Monoidal Function Composition
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo05ComposingWithMonoid*
]

---

## Trait Monoid
<br/>

```scala
trait Monoid[A] {

  def empty: A
  def combine(x: A, y: A): A

  def combineAll(as: List[A]): A =    // combines all functions in a List of functions
    as.foldLeft(empty)(combine)
}
```

--

<br/>
When composing functions with Monoid the functions must have the same input and output type.
You cannot compose functions of type *A => B*, only functions of type *A => A*.

---

## Default Monoid Instance for *Function1*
<br/>

```scala
// This one is the default Function1-Monoid in Cats
// It requires A to be a Monoid too.
//
implicit def function1Monoid[A: Monoid]: Monoid[A => A] = new Monoid[A => A] {
  
  override def empty: A => A =
    _ => Monoid[A].empty
  override def combine(f: A => A, g: A => A): A => A =
    a => Monoid[A].combine(f(a), g(a))
}
```
<br/>

--

- This instance defines a Monoid for Functions of type *A => A*.
- It requires type *A* to be a Monoid too.
- *empty* defines a function which ignores it's input and returns *Monoid[A].empty*.
- *combine* takes two functions *f* and *g*, invokes *f(a)* and *g(a)* on it's input and returns the combined result.

---

## Composition with Monoid
<br/>

```scala
val f: Int => Int = _ + 1
val g: Int => Int = _ * 2
val h: Int => Int = _ + 100
```

--

<br/>
```scala
import Monoid.function1Monoid

(f combine g)(4)                                 // 13
(f |+| g)(4)                                     // 13

(f |+| g |+| h)(4)                               // 117
Monoid[Int => Int].combineAll(List(f, g, h))(4)  // 117
```

--

<br/>
Another Monoid instance yields a different result.

---

## Instance for *function1ComposeMonoid*
<br/>

```scala
implicit def function1ComposeMonoid[A]: Monoid[A => A] = new Monoid[A => A] {
  override def empty: A => A = identity
  override def combine(f: A => A, g: A => A): A => A = f compose g
}
```
<br/>

--

- This instance composes the Functions with *Function1#compose*.

--

<br/>
```scala
import Monoid.function1ComposeMonoid

(f combine g)(4)                                 // 9
(f |+| g)(4)                                     // 9

(f |+| g |+| h)(4)                               // 209
Monoid[Int => Int].combineAll(List(f, g, h))(4)  // 209
```

---

## Instance for *function1AndThenMonoid*
<br/>

```scala
implicit def function1AndThenMonoid[A]: Monoid[A => A] = new Monoid[A => A] {
  override def empty: A => A = identity
  override def combine(f: A => A, g: A => A): A => A = f andThen g
}
```
<br/>

--

- This instance composes the Functions with *Function1#andThen*.

--

<br/>
```scala
import Monoid.function1AndThenMonoid

(f combine g)(4)                                 // 10
(f |+| g)(4)                                     // 10

(f |+| g |+| h)(4)                               // 110
Monoid[Int => Int].combineAll(List(f, g, h))(4)  // 110
```

---

class: middle, center

# 6. *Function1* as Functor
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo06Functor*
]

---

## Functor
<br/>

A Functor is any Context F[\_] that provides a function *map* ...<br/>
and abides by the Functor laws (which are not presented here).
<br/>
<br/>

```scala
trait Functor[F[_]] {

  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

---

## Functor instance

A Functor instance for *Functions*
(found automatically by the compiler if defined in implicit scope,
i.e inside the *Functor* companion object):

```scala
implicit def function1Functor[P]: Functor[Function1[P, ?]] =
  new Functor[Function1[P, ?]] {
    override def map[A, B](f: Function1[P, A])(g: A => B): Function1[P, B] =
      f andThen g
  }
```

--

A Functor instance for *Either* (just for comparison):

```scala
implicit def eitherFunctor[L]: Functor[Either[L, ?]] =
  new Functor[Either[L, ?]] {
    override def map[A, B](fa: Either[L, A])(f: A => B): Either[L, B] =
      fa map f
  }
```

--

Using the *Function1* Functor:

```scala
val f: Int => Int = _ + 3
val g: Int => Int = _ * 2
val h = Functor[Function1[Int, ?]].map(f)(g)
val res = h(2)  // 10
```

---

## Functor syntax

defined as <u>implicit conversion</u> ...

--

in a specific way for *Functor[Function1]*:

```scala
implicit class FunctorSyntaxFunction1[P, A](fa: Function1[P, A]) {
  def map[B](f: A => B): Function1[P, B] = Functor[Function1[P, ?]].map(fa)(f)
}
```

--

or in a generic way for any *Functor[F[_]]*:

```scala
implicit class FunctorSyntax[F[_]: Functor, A](fa: F[A]) {
  def map[B](f: A => B): F[B] = Functor[F].map(fa)(f)
}
```

--

This allows for convenient invocation of *map*<br/>
as if *map* were a method of *Function1*:

```scala
val f: Int => Int = _ + 3
val g: Int => Int = _ * 2
val h = f map g
val res = h(2)  // 10
```

---

## A pipeline of functions
<br/>
--

```scala
val s2i: String => Int = _.toInt
val plus2: Int => Int = _ + 2
val div10By: Int => Double = 10.0 / _
val d2s: Double => String = _.toString
```
<br/>

--

composed with *map*:

```scala
val fMapped = s2i map plus2 map div10By map d2s // requires -Ypartial-unification
val res1 = fMapped("3") // 2.0 !!!
```

--

<br/>
### *Function1* can also be seen as a Monad ...

---

class: middle, center

# 7. *Function1* as Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo07Monad*
]

---

## Monad
<br/>

A Monad is any Context F[\_] that provides the functions *pure* and *flatMap* ...<br/>
and abides by the Monad laws (which are not presented here).
<br/>
<br/>

```scala
trait Monad[F[_]] extends Functor[F] {

  def pure[A](a: A): F[A]
  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
}
```

---

## Monad instance

A Monad instance for *Functions*
(found automatically by the compiler if defined in implicit scope,
i.e inside the *Monad* companion object):

```scala
implicit def function1Monad[P]: Monad[P => ?] = new Monad[P => ?] {
  override def pure[A](r: A): P => A = _ => r
  override def flatMap[A, B](f: P => A)(g: A => P => B)
    : P => B = p => g(f(p))(p)
}
```

--

Alternative instance definition:

```scala
implicit def function1Monad[P]: Monad[Function1[P, ?]] = new Monad[Function1[P, ?]] {
  override def pure[A](r: A): Function1[P, A] = _ => r
  override def flatMap[A, B](f: Function1[P, A])(g: A => Function1[P, B])
    : Function1[P, B] = p => g(f(p))(p)
}
```

--

A Monad instance for *Either* (just for comparison):

```scala
implicit def eitherMonad[L]: Monad[Either[L, ?]] = new Monad[Either[L, ?]] {
  override def pure[A](r: A): Either[L, A] = Right(r)
  override def flatMap[A, B](fa: Either[L, A])(f: A => Either[L, B])
    : Either[L, B] = fa flatMap f
}
```

---

## Monad syntax

defined as <u>implicit conversion</u> ...

--

in a specific way for *Monad[Function1]*:

```scala
implicit class MonadSyntaxFunction1[P, A](f: Function1[P, A]) {
  def flatMap[B](g: A => P => B): P => B = Monad[Function1[P, ?]].flatMap(f)(g)
}
```

--

or in a generic way for any *Monad[F[_]]*:

```scala
implicit class MonadSyntax[F[_]: Monad, A](fa: F[A]) {
  def flatMap[B](f: A => F[B]): F[B] = Monad[F].flatMap(fa)(f)
}
```

--

This allows for convenient invocation of *flatMap*<br/>
as if *flatMap* were a method of *Function1*:

```scala
val h = f flatMap g
```

instead of:

```scala
val h = Functor[Function1[Int, ?]].flatMap(f)(g)
```

---

## A pipeline of functions (Reader Monad)
--

```scala
val countLines: String => Int = text => text.split("\n").length
val countWords: String => Int = text => text.split("\\W+").length
val countChars: String => Int = text => text.length
```

--

FlatMapping over *Function1*:

```scala
val computeStatistics1: String => (Int, Int, Int) =
  countLines flatMap { nLines =>      // define a pure program which does nothing
    countWords flatMap { nWords =>
      countChars map { nChars =>
        (nLines, nWords, nChars)
      } } }
val stat1: (Int, Int, Int) = computeStatistics1(getInput) // exec program (impure)
```

--

alternatively with a for-comprehension:

```scala
val computeStatistics2: String => (Int, Int, Int) =
  for {                               // define a pure program which does nothing
    nLines <- countLines // uses Function1#flatMap
    nWords <- countWords
    nChars <- countChars
  } yield (nLines, nWords, nChars)
val stat2: (Int, Int, Int) = computeStatistics2(getInput) // exec program (impure)
```

---

### Another Reader Monad example - a bit more realistic ...

```scala
val users: Map[Int, String] = Map(
          1 -> "dade", 2 -> "kate", 3 -> "margo")
val passwords: Map[String, String] = Map(
          "dade" -> "zerocool", "kate" -> "acidburn", "margo" -> "secret")

case class Db(usernames: Map[Int, String], passwords: Map[String, String])
val db = Db(users, passwords)

type DbReader[A] = Db => A    // ^= Function1[Db, A]

def findUsername(userId: Int): DbReader[Option[String]] =
  db => db.usernames.get(userId)

def checkPassword(username: String, password: String): DbReader[Boolean] =
  db => db.passwords.get(username).contains(password)

def checkLogin(userId: Int, password: String): DbReader[Boolean] = // ^= Function1[Db, Boolean] ^= DB => Boolean
  for {
    optUsername <- findUsername(userId)
    passwordOk <- optUsername
      .map(name => checkPassword(name, password))
      .getOrElse((_:Db) => false)
  } yield passwordOk

val login1Ok = checkLogin(1, "zerocool")(db) // true
val login4Ok = checkLogin(4, "davinci")(db) // false
```

Example taken from "Scala with Cats" (see chapter Resources for link)

---

class: middle, center

# 8. Kleisli composition done manually
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo08KleisliDoneManually*
]

---

## The Problem:

--

```scala
// Functions: A => F[B], where F is Option in this case
val s2iOpt: String => Option[Int] = s => Option(s.toInt)
val plus2Opt: Int => Option[Int] = i => Option(i + 2)
val div10ByOpt: Int => Option[Double] = i => Option(10.0 / i)
val d2sOpt: Double => Option[String] = d => Option(d.toString + " !!!")
```

These functions take an *A* and return a *B* inside of a context *F[\_]: A => F[B]*<br/>
In our case *F[\_]* is *Option*, but could be *List*, *Future* etc.

--

We want to compose these functions to a single function
which is then fed with some input string.

--

Let's try *map*.

```scala
val fMapped: String => Option[Option[Option[Option[String]]]] = str =>
  s2iOpt(str) map { i1 =>
    plus2Opt(i1) map { i2 =>
      div10ByOpt(i2) map {
        d => d2sOpt(d)
      }}}
```

We get nested *Option*s. So lets try *flatMap* on the *Option* context.

---

### FlatMapping on the *Option* context

--

with *flatMap* (this works):

```scala
val flatMappedOnOpt1: String => Option[String] = input =>
  s2iOpt(input) flatMap { i1 =>
    plus2Opt(i1) flatMap { i2 =>
      div10ByOpt(i2) flatMap { d =>
        d2sOpt(d)
      }}}
val res1: Option[String] = flatMappedOnOpt1("3") // Some(2.0)
```

--

or with a for-comprehension (this looks nicer):

```scala
val flatMappedOnOpt2: String => Option[String] = input => for {
  i1 <- s2iOpt(input)
  i2 <- plus2Opt(i1)
  d <- div10ByOpt(i2)
  s <- d2sOpt(d)
} yield s
val res2: Option[String] = flatMappedOnOpt2("3") // Some(2.0)
```

--

<u>But:</u> We still have to bind the variables *i1, i2, d* and *s* to names.<br/>
&nbsp; &nbsp; &nbsp; &nbsp; We would like to build a function pipeline with some kind of *andThenF*.
<br/><br/>
&nbsp; &nbsp; &nbsp; &nbsp; *s2iOpt andThenF plus2Opt andThenF div10ByOpt andThenF d2sOpt*

---

## Kleisli Composition

Kleisli composition takes two functions *A => F[B]* and *B => F[C]* and yields a new function
*A => F[C]* where the context *F[\_]* is required to be a Monad.

--

Let's define *kleisli*:

--

```scala
def kleisli[F[_]: Monad, A, B, C](f: A => F[B], g: B => F[C]): A => F[C] =
  a => Monad[F].flatMap(f(a))(g)
```

--

Using *kleisli*:

```scala
val kleisliComposed1: String => Option[String] =
  kleisli(kleisli(kleisli(s2iOpt, plus2Opt), div10ByOpt), d2sOpt)

val resKleisli1 = kleisliComposed1("3")    // 2.0 !!!
```

--

This works, but is still not exactly what we want.<br/>
*kleisli* should behave like a method of *Function1*.

---

## *kleisli* defined on *Function1*

--

<br/>
with an implicit conversion:

```scala
implicit class RichFunction1[F[_]: Monad, A, B](f: A => F[B]) {
  def kleisli[C](g: B => F[C]): A => F[C] = a => Monad[F].flatMap(f(a))(g)
  def andThenF[C](g: B => F[C]): A => F[C] = f kleisli g
  def >=>[C](g: B => F[C]): A => F[C] = f kleisli g     // Haskell's fish operator
}
```

--

<br/>
Using it:

```scala
val kleisliComposed2: String => Option[String] =
  s2iOpt kleisli plus2Opt kleisli div10ByOpt kleisli d2sOpt
kleisliComposed2("3") foreach println    // 2.0 !!!
```

--

```scala
(s2iOpt andThenF plus2Opt andThenF div10ByOpt andThenF d2sOpt) foreach println
```

--

```scala
(s2iOpt >=> plus2Opt >=> div10ByOpt >=> d2sOpt) foreach println
```

---

class: middle, center

# 9. *case class Kleisli*
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo09KleisliCaseClass*
]

---

## *case class Kleisli*
<br/>

That was my artefact. Cats does not provide a *kleisli* method on *Function1*.
Cats instead provides a *case class Kleisli* with the functionality shown above and more.

--

I tinkered my own impl in *mycats.Kleisli* which works much like the Cats impl: see next slide.

---

### *case class Kleisli*

```scala
case class Kleisli[F[_], A, B](run: A => F[B]) {

  def apply(a: A): F[B] = run(a)

  def map[C](f: B => C)(implicit F: Functor[F]): Kleisli[F, A, C] =
    Kleisli { a => F.map(run(a))(f) }

  def flatMap[C](f: B => Kleisli[F, A, C])(implicit M: Monad[F]): Kleisli[F, A, C] =
    Kleisli { a => M.flatMap(run(a))(b => f(b).run(a)) }

  def flatMapF[C](f: B => F[C])(implicit M: Monad[F]): Kleisli[F, A, C] =
    Kleisli { a => M.flatMap(run(a))(f) }

  def andThen[C](f: B => F[C])(implicit M: Monad[F]): Kleisli[F, A, C] =
    flatMapF(f)

  def andThen[C](that: Kleisli[F, B, C])(implicit M: Monad[F]): Kleisli[F, A, C] =
    this andThen that.run

  def compose[Z](f: Z => F[A])(implicit M: Monad[F]): Kleisli[F, Z, B] =
    Kleisli(f) andThen this.run

  def compose[Z](that: Kleisli[F, Z, A])(implicit M: Monad[F]): Kleisli[F, Z, B] =
    that andThen this
}
```

The case class methods delegate to the wrapped *run* function
and return the resulting *run* function rewrapped in a *Kleisli* instance.

---

### *Kleisli* companion object with Monad instance
<br/>

```scala
object Kleisli { self =>

  def pure[F[_], A, B](b: B)(implicit F: Monad[F]): Kleisli[F, A, B] =
    Kleisli { _ => F.pure(b) }

  object ops {

    implicit def kleisliMonad[F[_] : Monad, A]: Monad[Kleisli[F, A, ?]] =

      new Monad[Kleisli[F, A, ?]] {

        override def pure[B](b: B): Kleisli[F, A, B] = self.pure(b)

        override def flatMap[B, C](kl: Kleisli[F, A, B])(f: B => Kleisli[F, A, C])
            : Kleisli[F, A, C] = kl flatMap f
      }
  }
}
```

---

## *Kleisli#flatMap*

```scala
def flatMap[C](f: B => Kleisli[F, A, C])(implicit M: Monad[F]): Kleisli[F, A, C] = Kleisli { a =>
  M.flatMap(run(a))(b => f(b).run(a))
}
```

*flatMap* composes *this.run: A => F[B]* with the function *f: B => Kleisli[F, A, C]*
yielding a new *Kleisli[F, A, C]* wrapping a new function *run: A => F[C]*.

--

<br/>
```scala
val kleisli1: String => Option[String] = input =>
  Kleisli(s2iOpt).run(input) flatMap { i1 =>
    Kleisli(plus2Opt).run(i1) flatMap { i2 =>
      Kleisli(div10ByOpt).run(i2) flatMap { d =>
        Kleisli(d2sOpt).run(d)
      } } }
kleisli1("3") foreach println
```

--

```scala
val kleisli2: String => Option[String] = input => for {
  i1 <- Kleisli(s2iOpt).run(input)
  i2 <- Kleisli(plus2Opt).run(i1)
  d <- Kleisli(div10ByOpt).run(i2)
  s <- Kleisli(d2sOpt).run(d)
} yield s
kleisli2("3") foreach println
```

---

## *Kleisli#flatMapF*
<br/>

As we saw *Kleisli#flatMap* is not very convenient.
We have to bind values to variables and thread them through the for-comprehension.
*flatMapF* is easier to use.

--

<br/>
```scala
def flatMapF[C](f: B => F[C])(implicit M: Monad[F]): Kleisli[F, A, C] =
  Kleisli { a => M.flatMap(run(a))(f) }
```

*flatMapF* composes *this.run: A => F[B]* with the function *f: B => F[C]*
yielding a new *Kleisli[F, A, C]* wrapping a new function *run: A => F[C]*.

--

<br/>
```scala
val kleisli4: Kleisli[Option, String, String] =
  Kleisli(s2iOpt) flatMapF plus2Opt flatMapF div10ByOpt flatMapF d2sOpt

kleisli4.run("3") foreach println
```

---

## *Kleisli#andThen*
<br/>

The behaviour of *flatMap* is exactly what we expect from *andThen*.

--

<br/>
```scala
def andThen[C](f: B => F[C])(implicit M: Monad[F]): Kleisli[F, A, C] =
  flatMapF(f)
```
--

The first version of *andThen* is an alias for *flatMapF*.

--

<br/>
```scala
(Kleisli(s2iOpt) andThen plus2Opt andThen
    div10ByOpt andThen d2sOpt) foreach println
```

---

## *Kleisli#andThen*
<br/>

--

```scala
def andThen[C](that: Kleisli[F, B, C])(implicit M: Monad[F]): Kleisli[F, A, C] =
  this andThen that.run
```

This overloaded version of *andThen* doesn't take a function *f: B => F[C]*.
Instead it takes a *Kleisli[F, B, C]* wrapping such a function.
This version allows us to concatenate several Kleislis to a pipeline.

--

<br/>
```scala
(Kleisli(s2iOpt) andThen Kleisli(plus2Opt) andThen
    Kleisli(div10ByOpt) andThen Kleisli(d2sOpt)) foreach println
```

---

## *Kleisli#compose*
<br/>

As with *andThen* there are two versions of *compose*.
They work like *andThen* with the arguments flipped.

--

<br/>
```scala
def compose[Z](f: Z => F[A])(implicit M: Monad[F]): Kleisli[F, Z, B] =
  Kleisli(f) andThen this.run

def compose[Z](that: Kleisli[F, Z, A])(implicit M: Monad[F]): Kleisli[F, Z, B] =
  that andThen this
```

--

<br/>
```scala
(Kleisli(d2sOpt) compose div10ByOpt compose
    plus2Opt compose s2iOpt) foreach println

(Kleisli(d2sOpt) compose Kleisli(div10ByOpt) compose
    Kleisli(plus2Opt) compose Kleisli(s2iOpt)) foreach println
```

---

class: middle, center

# 10. Reader Monad
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *demo.Demo10Reader*
]

---

## Reader again
<br/>

We already saw, that the *Function1* Monad is the *Reader* Monad.

But *Kleisli* can also be used as *Reader*, if *F[\_]* is fixed to the *Id* context.

--

<br/>
```scala
type Id[A] = A

type ReaderT[F[_], A, B] = Kleisli[F, A, B]
val ReaderT = Kleisli

type Reader[A, B] = Kleisli[Id, A, B]

object Reader {
  def apply[A, B](f: A => B): Reader[A, B] = ReaderT[Id, A, B](f)
}
```

---

## *Reader#flatMap*
<br/>

--

```scala
val s2i: String => Int = _.toInt
val plus2: Int => Int = _ + 2
val div10By: Int => Double = 10.0 / _
val d2s: Double => String = _.toString + " !!!"
```

--

<br/>
```scala
val reader1: String => String = input => for {
  i1 <- Reader(s2i).run(input)
  i2 <- Reader(plus2).run(i1)
  d <- Reader(div10By).run(i2)
  s <- Reader(d2s).run(d)
} yield s

println(reader1("3"))     // 2.0 !!!
```

--

<br/>
Again *flatMap* is not the best choice as we have to declare
all these intermediate identifiers in the for-comprehension.

---

## *Reader#andThen* (two versions)
<br/>

--

```scala
val reader2 =
  Reader(s2i) andThen Reader(plus2) andThen Reader(div10By) andThen Reader(d2s)

println(reader2("3"))     // 2.0 !!!
```

--

<br/>
```scala
val reader3 =
  Reader(s2i) andThen plus2 andThen div10By andThen d2s

println(reader3("3"))     // 2.0 !!!
```

--

<br/>
All methods of *Kleisli* are available for Reader,<br/>
because *Kleisli* <u>**is**</u> *Reader* with *Id*.

---

### The Reader example from before runs with minor changes.

```scala
val users: Map[Int, String] = Map(
              1 -> "dade", 2 -> "kate", 3 -> "margo" )
val passwords: Map[String, String] = Map(
              "dade" -> "zerocool", "kate" -> "acidburn", "margo" -> "secret" )

case class Db(usernames: Map[Int, String], passwords: Map[String, String])
val db = Db(users, passwords)

type DbReader[A] = Reader[Db, A]      // ^= Kleisli[Id, Db, Boolean]

def findUsername(userId: Int): DbReader[Option[String]] =
  Reader { db => db.usernames.get(userId) }

def checkPassword(username: String, password: String): DbReader[Boolean] =
  Reader { db => db.passwords.get(username).contains(password) }

def checkLogin(userId: Int, password: String): DbReader[Boolean] =
  for {
    optUsername <- findUsername(userId)
    passwordOk <- optUsername
      .map(name => checkPassword(name, password))
      .getOrElse(Kleisli.pure[Id, Db, Boolean](false))
  } yield passwordOk

val loginOk1 = checkLogin(1, "zerocool").run(db) // true
val loginOk2 = checkLogin(4, "davinci").run(db) // false
```

Example taken from "Scala with Cats" (see chapter Resources for link)

---

class: middle, center

# 11. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Resources (1/2)

<br/>

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/composing-functions

- "Scala with Cats"<br/>
  Book by Noel Welsh and Dave Gurnell<br/>
  https://underscore.io/books/scala-with-cats/

- "Functional Programming in Scala"<br/>
  Book by Paul Chiusano and Dave Gurnell<br/>
  https://www.manning.com/books/functional-programming-in-scala

- Cats documentation for *Kleisli*:<br/>
  https://typelevel.org/cats/datatypes/kleisli.html
  
---
 
## Resources (2/2)

<br/>

- Miles Sabin's pull request for partial unification:<br/>
  https://github.com/scala/scala/pull/5102

- "Explaining Miles's Magic:<br/>
  Gist of Daniel Spiewak on partial unification<br/>
  https://gist.github.com/djspiewak/7a81a395c461fd3a09a6941d4cd040f2

- "Kind Projector Compiler Plugin:<br/>
  https://github.com/non/kind-projector

---

class: middle, center

## Thanks for Listening
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/use-applicative-where-applicable


</textarea>

    <script src="remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({
        // sourceUrl: 'some-source.md',

        // Set the slideshow display ratio
        // Default: '4:3'
        // Alternatives: '16:9', ...
        ratio: '4:3',

        // Navigation options
        navigation: {
          // Enable or disable navigating using scroll
          // Default: true
          // Alternatives: false
          scroll: false,

          // Enable or disable navigation using touch
          // Default: true
          // Alternatives: false
          touch: true,

          // Enable or disable navigation using click
          // Default: false
          // Alternatives: true
          click: false
        }
      });
    </script>
  </body>
</html>
